#!/usr/bin/env node

var fs = require("fs")
var path = require("path")
var program = require("commander")
var marked = require("marked")
var title = require("to-title-case")
var chalk = require("chalk")
var gh = require("github-url-to-object")
var merge = require("merge")
var Heroku = require("../lib/heroku")
var App = require("..")

function green(msg) {
  console.log(chalk.green(msg))
}

function red(msg) {
  console.error(chalk.red(msg))
}

program
  .command("init")
  .description("Create an app.json for the current directory's app")
  .option("-a, --app <heroku-app-name>", "Specify a Heroku app from which to derive addons and env")
  .action(function(program){

    if (fs.existsSync(process.cwd() + "/app.json")) {
      return console.log("This directory already contains an app.json. Run `app.json validate` to verify it.")
    }

    var app = App.new()
    app.name = title(path.basename(process.cwd()))
    app.description = "TODO: Add a short description about " + app.name
    app.keywords = ["small", "sharp", "tool"]
    app.website = "TODO: Add website URL"
    app.repository = "TODO: Add repository URL"
    app.logo = "TODO: Add logo URL"
    app.addons = []
    app.env = {}

    var done = function() {
      fs.writeFile(process.cwd() + "/app.json", app.toJSON, function(err) {
        if (err) console.error(err)
        green("Created app.json\n")
        console.log(app.toJSON)
      })
    }

    if (program.app) {
      Heroku.deriveAddonsAndEnv(program.app, function(err, addons_and_env) {
        if (err) return console.error(err)
        app = merge(app, addons_and_env)
        return done()
      })

    } else {
      Heroku.deriveAppNamesFromLocalGitConfig(function(err, names) {
        if (err) return console.error(err)

        if (!names.length) return done()

        if (names.length > 1) {
          console.log("Multiple Heroku git remotes found. Try one of these commands:\n")
          names.forEach(function(name) {
            console.log("app.json init -a " + name)
          })
          return
        }

        Heroku.deriveAddonsAndEnv(names[0], function(err, addons_and_env) {
          if (err) return console.error(err)
          app = merge(app, addons_and_env)
          return done()
        })

      })
    }

  })

program
  .command("validate")
  .description("Validate the app.json file in the current directory")
  .action(function(program){

    var manifest = process.cwd() + "/app.json"
    if (fs.existsSync(manifest)) {

      try {
        JSON.parse(fs.readFileSync(manifest).toString())
      } catch(err) {
        return red("Found an app.json file, but it's invalid JSON.")
      }

      var app = App.new(manifest)

      if (app.valid) {
        green("\nYour app.json file is valid!\n")
        console.log(app.toJSON)
      } else {
        red("\nFound an app.json file, but it's got some issues:\n")
        console.error(app.errorString)
      }
    } else {
      red("\nNo app.json found. Use `app.json init` to create one.\n")
    }
  })

program
  .command("schema")
  .option('--markdown', 'Write the schema in markdown format')
  .option('--html', 'Write the schema in HTML format')
  .description("Write the app.json schema to STDOUT")
  .action(function(program){
    if (program.markdown) {
      process.stdout.write(App.templates.schema.render(App.schema))
    } else if (program.html) {
      process.stdout.write(marked(App.templates.schema.render(App.schema)))
    } else {
      process.stdout.write(JSON.stringify(App.schema.properties, null, 2))
    }
  })

program
  .command("deploy [repo]")
  .description("Deploy an app.json-enabled app from GitHub using its shorthand URL.")
  .action(function(repo){
    var build
    console.log("Cloning from " + gh(repo).https_url)
    Heroku.clone(repo, function(err, buildResult) {
      if (err) return console.error(err)
      build = buildResult
      console.log("Created https://" + build.app.name + ".herokuapp.com")

      var poll = function() {
        Heroku.getBuildStatus(build.id, function(err, status) {
          if (err) return console.error(err)
          build = status

          switch(build.status) {
          case "pending":
            process.stdout.write(".")
            break
          case "failed":
            clearInterval(pollInterval)
            return console.error("Build failed: ", build.failure_message)
            break
          case "succeeded":
            clearInterval(pollInterval)
            console.log("\nBuild succeeded!")
            console.log(build.resolved_success_url)
            break
          }

        })
      }

      var pollInterval = setInterval(poll, 1000)

    })
  })

// Print this after the generated help text
program.on("--help", function(){
  console.log("  Use 'app <command> --help' to get more information about a specific command.")
  console.log('')
})

program.parse(process.argv)

if(program.args.length < 1){
  program.help()
}
